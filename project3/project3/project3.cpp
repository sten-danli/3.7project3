// project3.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include "Human.h"
#include "Men.h"
#include "Women.h"



int main()
{
	
	//Men men;
	//men.printtest();//这个对象将从父类调取。
	//men.printtest(1);//这个对象将从子类men调取。
	/*men.add_age(3);*/
	/*men.m_Age = 16;
	cout << men.m_Age << endl;*/
		
	//基类指针_纯虚函数_多态_虚析构
	//新玩法:
	//一虚函数的作用，为什么使用virtual
	Human* human = new Men;//父类指针可以new一个子类的对象.
	 //Men* men = new Human;//子类不可以new父类对象
	
	human->funcHumen();//虽然父类new了个子类对象，却只能调动父类中的函数,
	//既然父类指针无法调用子类函数，为什么还要父类指针new一个子类对象呢，有什么用处呢,
	//当我们把父类同名函数的声明出赋予virtual的时候就可以用一个指针使用子类内的函数了。
	human->eat();//在父类使用virtual后，此时就可以调用子类Men的 eat()函数了。
	human = new Women;//把指针指向Women就可以调动Women类里面的同函数名了。
	human->eat();//此时调动的就是Women类中的ent()函数了。
	//也可以这样玩
	human->Human::eat();//调动human eat()函数。
	//总结什么时候用到虚函数virtual当各类中的函数名函数体都一抹一样的话为了方便调用各个类中的同名函数就可以使用virtual方法。
	////override是为了防止用virtual时必须子类的函数和父类函数一模一样，当不一样时overide会提出错误,这个关键字用在子类中，为
	//虚函数专用。override就是用来说明派生类中的虚函数，你用了这个关键字后，编译器
	//编译器就会认为你这个函数eat是覆盖了父类中的同名函数的。
	//调动虚函数执行的是动态绑定，动态表示就是在我们程式运行的时候才能知道调用了那个子类的eat函数
	//动态绑定运行时才决定你的human对象绑定到那个eat函数上。
	//在函数声明中virtual void eat() final;也是虚函数专用，使用在父类，如果我们在父类的函数生命中加了final
	//那么任何尝试覆盖该函数的操作都会引发错误。

	//三 多态性是针对虚函数来说的，随着虚函数地提出，面向对象的里边的多态性就浮出了水面
	//多态性体现在具有承诺关系的父类和子类之间，子类重新定义了重写父类的成员函数，同时父类把
	//这个函数声明称了virtual，通过父类的指针，只有到了程序运行时期，找到动态绑定到父类指针上的对象
	//也可能是父类对象，然后系统内部实际上是要查一个虚函数的入口，从而调用父类或子类的eat
	//函数，这就是运行时期的多态性。

	//四 纯虚函数
	
	
	
}

